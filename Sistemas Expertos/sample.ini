; ====== Hechos atómicos y reglas del ejemplo ======
; Usamos hechos ordenados (A, B, C, ...) y evitamos duplicar con (not ...)

(defrule R3   ; H -> A
  (H) (not (A))
  =>
  (assert (A))
  (printout t "[R3] H -> A" crlf))

(defrule R1   ; A -> E
  (A) (not (E))
  =>
  (assert (E))
  (printout t "[R1] A -> E" crlf))

(defrule R5   ; E y K -> B
  (E) (K) (not (B))
  =>
  (assert (B))
  (printout t "[R5] E y K -> B" crlf))

(defrule R2   ; B -> D
  (B) (not (D))
  =>
  (assert (D))
  (printout t "[R2] B -> D" crlf))

(defrule R6   ; D y E y K -> C
  (D) (E) (K) (not (C))
  =>
  (assert (C))
  (printout t "[R6] D y E y K -> C" crlf))

; (R4 y R7 no se activarán con solo H,K, pero las dejamos por completitud)
(defrule R4   ; E y G -> C
  (E) (G) (not (C))
  =>
  (assert (C))
  (printout t "[R4] E y G -> C" crlf))

(defrule R7   ; G y K y F -> A
  (G) (K) (F) (not (A))
  =>
  (assert (A))
  (printout t "[R7] G y K y F -> A" crlf))

  ; ====== Ejecución ======
(reset)
; Base inicial de hechos: H, K
(assert (H))
(assert (K))

; (watch) para ver trazas (opcional)
(watch rules)
(watch facts)

(run)

; Al finalizar, puedes listar los hechos:
(facts)